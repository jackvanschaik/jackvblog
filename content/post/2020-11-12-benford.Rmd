---
title: "Analysis: Benford's Law in 2020 Election Results"
author: "Jack VanSchaik"
date: 2020-11-12
categories: ["R"]
tags: ["Election", "R", "Twitter"]
twitterImg: /images/benford.png
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```


## Introduction

[Benford's law is a problematic method of detecting election fraud](https://www.cambridge.org/core/journals/political-analysis/article/benfords-law-and-the-detection-of-election-fraud/3B1D64E822371C461AF3C61CE91AAF6D). Nevertheless, there have been some plots circulating on social media that claim to use Benford's law to indicate president elect Biden's vote counts in the 2020 election are fraudulent. 

Benford's law states that under certain conditions, the distribution of the first digits $d$ of numbers in a data set will follow this distribution:

$P(d) = \log_{10}(1 + \frac{1}{d})$

For this "law" to apply, data must span several orders of magnitude. Even then, it may not be applicable. One could easily synthesize a counterexample with multimodel data across several orders of magnitude. 


## Description of Analysis

I have analyzed 2020 presidential elections results (as of 11/12/2020) against the expection per Benford's law. Again, Benford's law is not the best tool to detect election fraud, but for the sake of argument lets assume it is. I performed an analysis to see if there were any anomalous (potentially fraudulent) election result in all 50 states for either Trump or Biden.

I downloaded county level 2020 election data for every county in all 50 states via https://www.nbcnews.com/politics/2020-elections/. I then compared vote data against Benford's law for each candidate in each state using both a Chi-Squared goodness of fit test and a Kruskal-Wallis rank sum test. If either of these tests were significant for a candidate in a give state, it indicates an anomaly there. I counted the total anomalies for each candidate, and display below p-values and plots for every state.

## Results

At the time of writing this, Trump had anomalies in 6 states where Biden only had anomalies in 4. I used a significance level of 0.05, roughly meaning we'd expect 2-3 anomalies for each candidate as a baseline (false positives). Very few of these detected anomalies were in swing states.

The method I used was very sensitive. Typically, running a series of test (like I've done here) calls for a multiplicity correction to lower the significance level and reduce false positives. I did not do a multiplicity correction in order to pick up as many potential anomalies as possible. 

Furthermore, an anomalous result could come from either a significant Chi-Squared test OR a Kurskal-Wallis test, adding to the sensitivity of my methodology. The candidates counts have to pass two tests instead of one.

The sensitivity of the tests, combined with low counts (6 for Trump, 4 for Biden) indicate that even if Benford's law was an applicable method of fraud detection for elections, it wouldn't be detecting much fraud in this election data at all. If this does indicate fraud however, Trump has more explaining to do than Biden. Regardless, there is no evidence of systemic voter fraud from either candidate.

## Complete Analysis With Source code

Here is a complete analysis in R

```{r, results="hide", message=FALSE}
library(tidyverse)
library(rvest)
library(xml2)
library(jsonlite)
```

## Functions to get data

```{r}
get_election_results <- function(state) {
    # Gets vote counts from NBC
    json_url <- sprintf("https://www.nbcnews.com/politics/2020-elections/%s-president-results?format=json", state)
    X <- fromJSON(json_url)
    y <- X$stateMapData
    
    county_names <- names(y)
    lapply(X$stateMapData, function(y) {
        Z <- y$candidates
        Z$county <- y$raceName
        Z
    }) %>%
        do.call(bind_rows, .) %>%
        filter(name %in% c("Donald Trump", "Joe Biden")) %>%
        transmute(
            state = state,
            county = county,
            candidate = clean_candidate(name),
            votes = vote
        ) %>%
        pivot_wider(state:county, names_from = candidate, values_from = votes)
}
```


## S3 Class For Benford's Law Analysis

```{r}
pbenford <- Vectorize(function(d) {
    stopifnot(d %in% 1:9)
    log10(1 + (1/d))
})

benford_table <- function(n) {
    data.frame(
        digit = as.character(1:9),
        expected = n *pbenford(1:9)
    )
}

benford_sample <- function(n) {
    benford_table(n) %>%
        mutate(expected = round(expected)) %>%
        apply(1, function(x) rep(x[1], x[2])) %>%
        unlist %>%
        as.character ->
        X
    
    if (length(X) == n) {
        return(X)
    }
    else if (length(X) < n) {
        return(c(X, sample(X, n - length(X), replace=TRUE)))
    }
    else {
        return(X[-1])
    }
}

benford <- function(X) {
    stopifnot(all(names(X) %in% c("state", "county", "trump", "biden")))
    
    N <- nrow(X)
    
    # Get digits
    X %>%
        transmute(
            state, county, 
            trump = substr(as.character(trump), 1, 1),
            biden = substr(as.character(biden), 1, 1)
        ) %>%
        pivot_longer(trump:biden, names_to = "candidate", values_to="digit") ->
        Y
    
    Y %>%
        group_by(candidate) %>%
        count(digit) %>%
        left_join(benford_table(N), by="digit") ->
        digit_table

    
    trump_sample <- filter(Y, candidate == "trump")$digit
    biden_sample <- filter(Y, candidate == "biden")$digit
    actual_sample <- benford_sample(N)
    
    tests <- data.frame(
        candidate = c("trump", "biden"),
        p_kw = c(
            kruskal.test(trump_sample, actual_sample)$p.value,
            kruskal.test(biden_sample, actual_sample)$p.value
        ),
        p_chisq = c(
            chisq.test(trump_sample, actual_sample)$p.value,
            chisq.test(biden_sample, actual_sample)$p.value
        )
    )
    
    structure(
        list(
            N = N,
            digit_table = digit_table,
            tests = tests,
            original_data = X
        ),
        class="benford"
    )
}

is.benford <- function(X) {
    inherits(X, "benford")
}

print.benford <- function(X) {
    cat("Benford Analysis", fill=TRUE)
    cat("N = ", X$N, fill=TRUE)
    print(X$tests)
}

plot.benford <- function(X) {
    ggplot(X$digit_table, aes(x=digit, y=n)) + 
        geom_bar(stat="identity") + 
        facet_wrap(.~candidate) +
        theme_minimal() +
        labs(y="Count", x="First Digit") +
        theme(legend.position = "none") +
        geom_line(aes(x=digit, y=expected, group=candidate), size=1.5)
}

```

## Helper Functions

```{r}
clean_candidate <- function(X) {
    case_when(
        str_detect(X, "(?i)trump") ~ "trump",
        str_detect(X, "(?i)biden") ~ "biden",
        str_detect(X, "(?i)jorgensen") ~ "jorgensen",
        TRUE ~ NA_character_
    )
}
```

## Get Results For All States

You'll notice I saved a static copy of the data onto my hard drive, and loaded it in. This serves a couple purposes, mainly reproducible and it speeds up my blogdown rendering time. Results are constantly changing as not all votes are counted yet, so I wanted to save an exact snapshot. I'd be happy to share the exact data file I used via email.

```{r, results="hide", message=FALSE, warning=FALSE}
states <- str_replace(tolower(state.name), fixed(" "), "-")

#state_election_results <- lapply(states, get_election_results)
#names(state_election_results) <- states
#saveRDS(state_election_results, "C:/Users/Jack/Documents/data/benford_blog/state_election_results.RDS")

state_election_results <- readRDS("C:/Users/Jack/Documents/data/benford_blog/state_election_results.RDS")

options(warn = -1)
benford_results <- lapply(state_election_results, benford)
names(benford_results) <- states
```

## Analyze Anomalies

```{r}
p_vals <- do.call(bind_rows, lapply(states, function(x) {
    y <- benford_results[[x]]$tests
    y$state <- x
    y
}))

p_vals %>%
    mutate(
        p_kw = round(p_kw, 5),
        p_chisq = round(p_chisq, 5),
        kw_abnormal = p_kw < 0.05,
        chisq_abnormal = p_chisq < 0.05,
        any_abnormal = (kw_abnormal == TRUE) | (chisq_abnormal == TRUE),
        abnormal_flag = as.numeric(any_abnormal)
    ) ->
    p_vals_2
```

## Viewing All Results

```{r}
p_vals_2 %>%
    filter(abnormal_flag == 1) %>%
    ggplot(aes(x=abnormal_flag, fill=candidate)) + geom_bar(stat="count", position = "dodge") +
    scale_fill_brewer(palette = "Set2") +
    theme_minimal() +
    labs(y="Count of Abnormalities", title="Abormalities per Benford's Law") +
    theme(axis.title.x = element_blank(), axis.text.x= element_blank())
```

Here's the data as a table. Feel free to browse results for any state and candidate:

```{r}
DT::datatable(p_vals_2)
```

## Plots for Every State

Here are plot of actual digits counts for each candidate in each state. The expected counts via Benfor's law have been over added on top (black line).

```{r}
lapply(names(benford_results), function(x) {
    plot(benford_results[[x]]) + labs(title=x)
})
```

## Session Info

This analysis was run in R. Here's the exact session I ran during the analysis:

```{r}
session_info()
```


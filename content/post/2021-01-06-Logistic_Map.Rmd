---
title: "Logistic Map with Rcpp"
description: "Calculating the logistic map with Rcpp"
date: 2021-01-06
categories: ["R"]
tags: ["R", "R markdown", "Chaos"]
twitterImg: images/clip.png
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
Sys.setenv(PATH = paste("C:\\RBuildTools\\4.0/usr/bin", Sys.getenv("PATH"), sep=";"))
Sys.setenv(BINPREF = "C:/RBuildTools/4.0/mingw64/bin/")
```

## Introduction

The [Logistic Map](https://en.wikipedia.org/wiki/Logistic_map) is pretty darn cool. I wanted to plot it with ggplot but I ran into some issues with computation time and it just looked downright awful. I decided to revisit this. I sped things up by with an optimized C++ function for computing the map, and plotted line segments instead of points. It's slightly better, but something I want to keep working on.

I'm sure there existing tools for creating really nice plots of the logistic map, but the fun part for me is doing it in R and learning along the way.

## Logistic Map Function in C++

I opted to code the actual "map" part of the logistic map in C++, since it needs a for loop. There are a few optimization done to lower the number of calculations needed and values returned. Only the last `N` values of the map are returned. 

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector log_map_c(NumericVector R) {
    double r = R[0];
    int N;
    int M;
    
    if (r < 3) {
        N = 1;
        M = 100;
    }
    else if (r < 3.44) {
        N = 2;
        M = 100;
    }
    else if (r < 3.54409) {
        N = 4;
        M = 200;
    }
    else {
        N = 1080;
        M = 7;
    }
    
    double y[N];
    double x = 0.5;
    int j = 0;
    for (int i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            x = r * x * (1 - x);
            y[j] = x;
        }
    }
    
    return NumericVector(y, y+sizeof(y)/sizeof(*y));
}

```

## R functions

Some finishing touches are done in the `log_map` R function, which returns stable values. The `closest` function maps points in `y` to their nearest point in `x`. The `logistic_map_df` function creates a data frame of line segments connecting stable values. 

```{r}
log_map <- function(r) {
    unique(round(log_map_c(r), 3))
}

closest <- function(x, y) {
    data.frame(
        y1 = x[Rfast::colMins(abs(outer(x, y, "-")))],
        y2 = y
    )
}

logistic_map_df <- function(left, right, N) {
    X <- seq(left, right, length.out = N)
    Z <- as.list(rep(NA, N - 1))
    r0 <- log_map(X[1])
    
    for (j in 2:N) {
        x <- X[j]
        r1 <- log_map(x)
        w <- closest(r0, r1)
        w$x1 <- X[j-1]
        w$x2 <- x
        Z[[j - 1]] <- w
        r0 <- r1
    }
    
    do.call(rbind, Z)
    
}
```

## A Few Plots

```{r}
library(ggplot2)
```

#### Low Resolution

This computes quickly and captures the gist of the logistic map, but isn't very pretty.

```{r}
data <- logistic_map_df(0, 4, 100)

ggplot(data, aes(x = x1, xend = x2, y = y1, yend=y2)) + 
    geom_segment() + labs(x="r", y="stable x values")
```

#### Better Resolution

```{r}
data <- logistic_map_df(0, 4, 600)

ggplot(data, aes(x = x1, xend = x2, y = y1, yend=y2)) + 
    geom_segment() + labs(x="r", y="stable x values")
```

#### Better Resolution, Zoomed to Chaotic Region

```{r}
data <- logistic_map_df(3.5, 4, 600)

ggplot(data, aes(x = x1, xend = x2, y = y1, yend=y2)) + 
    geom_segment() + labs(x="r", y="stable x values")
```

#### Points only, instead of lines

This doesn't look as good in the less chaotic areas. Chaotic areas are still, well, chaotic.

```{r}
log_map_range <- function(left, right, length.out=1000) {
    X <- seq(left, right, length.out = length.out)
    do.call(rbind, lapply(X, function(r) {
        data.frame(
            r = r,
            y = log_map(r)
        )
    }))
}

ggplot(log_map_range(3.5, 4, 600), aes(x = r, y=y)) + geom_point(shape=".")
```

## Session Info

```{r}
session_info()
```


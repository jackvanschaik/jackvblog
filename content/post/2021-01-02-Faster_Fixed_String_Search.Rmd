---
title: "Faster Fixed String Search with Rcpp"
description: "Speeding Up R String Searches with C++"
date: 2020-01-02
categories: ["R"]
tags: ["R", "programming", "Rcpp"]
twitterImg: images/clip.png
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
Sys.setenv(PATH = paste("C:\\RBuildTools\\4.0/usr/bin", Sys.getenv("PATH"), sep=";"))
Sys.setenv(BINPREF = "C:/RBuildTools/4.0/mingw64/bin/")
```

## Introduction

R performance can sometimes be improved by rewriting functions in C++. Rcpp makes this easy by creating an approachable interface between R and C++. Chapter 25 of [Hadley Wickham's Advanced R](https://adv-r.hadley.nz/rcpp.html) and [Masaki Tsuda's Rcpp for everyone](https://teuder.github.io/rcpp4everyone_en/) are great resources to learn more about this.

I decided to utilized Rcpp to speed up fixed string searches. The R functions `base::grepl` or `stringr::str_detect`, are usually sufficiently fast if the target data is sufficiently small. I needed to search though a few dozen gigabytes of text though, so this was going too slow. Stripping `stringr::str_detect` to its underlying C call wasn't quite fast enough:

```{r, eval=FALSE}
.Call(C_stri_detect_fixed, str, pattern, negate, max_count, opts_fixed)
```

So I went the Rcpp route to write a faster implementation. Here it is:

## A Faster Fixed String Search with Rcpp

Here's the cpp code. This can go in a file in your working directory, I called mine `faster_fixed_text_search.cpp`.

I didn't need vectorization so I got the first element of each argument and converted to char*. There's a few sanity checks for the string lengths. Finally, the target string is searched one character at a time. If there's a match, the next character from the search string is compared, and so on until the whole string matches. This minimizes the number of character-wise comparisons and returns as soon as a single match is found. 

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
bool ffts(CharacterVector target, CharacterVector srch) {
    String x = target[0];
    String y = srch[0];
    const char* X = x.get_cstring();
    const char* Y = y.get_cstring();
    int N_x = std::char_traits<char>::length(X);
    int N_y = std::char_traits<char>::length(Y);
    
    if (N_x < N_y) {
        return false;
    }
    
    if (N_x == N_y) {
        if (x == y) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        char c = Y[0];
        int c_i = 0;
        
        for(int j = 0; j < N_x; j++) {
            char rchar = X[j];
            if (c == rchar) {
                c_i += 1;
                if (c_i == N_y) {
                    return true;
                }
                c = Y[c_i];
            }
            else {
                c = Y[0];
                c_i = 0;
            }
        }
    }
    
    return false;
}
```

You can load this in with `sourceRcpp("faster_fixed_text_search.cpp)` from the Rcpp package, or use an Rcpp code chunk in RMarkdown. 

## Benchmarking

Let's benchmark against a few of the standard fixed string search implementations:

```{r}
library(stringi)
library(stringr)

base_r <- function(target, srch) grepl(srch, target, fixed=TRUE)
string_r <- function(target, srch) str_detect(target, fixed(srch))
string_i <- function(target, srch) .Call(
    stringi:::C_stri_detect_fixed, target, srch, FALSE, -1, NULL
)

target <- "I like to code in R"
search <- "code"

bench::mark(
    base_r(target, search),
    string_r(target, search),
    string_i(target, search),
    ffts(target, search)
)
```

So the `ffts` function is the fastest, with a slight edge on the base `grepl` function. `str_detect` is the slowest, as it is essentially a wrapper around the `stringi:::C_stri_detect_fixed` function, which still doesn't perform as well as `ffts`.

The advantage of the `stringi` method is that it is vectorized over a pattern. To be fair to `stringi`, let's compare performance when checking multiple targets.


```{r}
bench::mark(
    string_i("123abc", letters),
    unlist(lapply(letters, ffts, target="123abc"), use.names = FALSE)
)
```

So `stringi`'s C function is faster here. This is probably because `ffts` is scanning the string for each search term but `stringi` isn't. I'll probably implement a vectorized version of `ffts` that only does a single scan. Maybe it will be faster?

## Conclusion

If you're searching a string in R for a single fixed value, the fastest option is to either use `grepl` with `fixed = TRUE`, or go the Rcpp route. My default for a while had been `stringr::str_detect` because `stringr` is very nicely put together. This was performant enough for most of what I was doing at my old job (string searching through > 10 million rows of short text), but needed a slight speed boost for my current NLP work.

Thanks for reading!

## Session Info

```{r}
session_info()
```


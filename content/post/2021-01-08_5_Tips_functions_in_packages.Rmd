---
title: "5 Tips For Writing Functions in R Packages"
description: A few tips for improving your workflow
date: '2021-01-08'
categories: R
tags:
- R
- programming
twitterImg: /images/hilarious_r_tools_meme.png
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

## Introduction

If you write a lot of R code, making packages can be very helpful. You can create a package for internal use to standardize your workflow. If you want to share your package with the R community, you can post it on CRAN or GitHub. Either way, it's a valuable skill. [Wickham and Bryan's "R packages"](https://r-pkgs.org/) is a good resource to learn more. 

Core to packages are functions. Here's five tricks I use to make including functions in my packages as easy as possible. This is heavily inspired by the "Building Tidy Tools" workship I attended at rstudio::conf(2020).

## 1.) Put Related Functions In The Same File

While it's tempting to write all your code in a single file, like you might in a R script, that's not always best practice in package development. Any R script in the `R/` folder gets included in your package, so you can create as many files as you like.

There's a nice trick for creating new script files:

```{r, eval=FALSE}
usethis::use_r("function_group_1.R") # will create R/function_group_1.R
```

You can use the next tip, to save yourself some typing every time.

If you must have several functions in the same file, you can take advantage of R's code indentation to make life easier. You can make your own collapse points with comments in this format.

```{r}
# Section Name 1 ####
```

Super handy!

## 2.) Put usethis and devtools in Your R profile

Your R profile is a script that gets run any time you start up R. It's a great way to set options or load packages that you need in every R session. Here's what mine looks like:

```{r, eval=FALSE}
library(devtools)
library(usethis)
```

These two packages are very helpful for package development, so it's useful to have their functions readily available. 

The location of your R profile may vary, but if you're in Rstudio you can open it for editing with:

```{r, eval=FALSE}
usethis::edit_r_profile() 
```

## 3.) Use check() often

The `check()` function in `devtools` will do thorough diagnostics of any R functions in your package. I run this after making any significant changes to a function. Not only will it verify that your package can be installed, it will give informative warnings about the syntax of your code. 

## 4.) Use Shortcuts for Roxygen

[Roxygen](https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html) is a way of documenting your code with specialized comments. It can be hard for me to remember all the details of Roxygen, so I always insert a Roxygen skeleton (Ctrl + Alt + Shift + R) in Rstudio.

Here's a function:

```{r, eval=FALSE}
dist <- function(x, y) {
    abs(y - x)
}
```

Here's what it looks like once you add the skeleton:

```{r, eval=FALSE}
#' Title
#'
#' @param x 
#' @param y 
#'
#' @return
#' @export
#'
#' @examples
dist <- function(x, y) {
    abs(y - x)
}
```

Here's what it looks like filled out:

```{r, eval=FALSE}
#' Distance Function
#'
#' @param x a numeric vector
#' @param y another numeric vector
#'
#' @return manhattan distance between x and y
#' @export
#'
#' @examples
#' x <- 1:3
#' y <- c(1,0,4)
#' dist(x, y)
dist <- function(x, y) {
    abs(y - x)
}
```

Once you've filled out your Roxygen skeleton, you can update your documentation with the `document` function from `devtools`:

```{r, eval=FALSE}
document()
```

This will let you know if your roxygen comments have any issues and update your package documentation behind the scenes.

## 5.) Use package::function Syntax Early On

The preferred way to use external functions in your package is to use the `package::function` syntax like so:

```{r, eval=FALSE}
#' Lapply with a progress bar
#'
#' This is just lapply with \link[progress]{progress_bar}
#'
#' @param X List to be iterated over
#' @param f Function to apply to X
#' @param ... Additional arguments to `f`
#'
#' @return `lapply(X, f, ...)`, progress bar output is printed
#' @export
plapply <- function(X, f, ...) {
    n <- length(X)
    pb <- progress::progress_bar$new(format = "[:bar]",
                                     total = n, width = 100, show_after = 0.1)
    lapply(1:n, function(j) {
        y <- X[[j]]
        pb$tick()
        f(y, ...)
    })
}
```

And then update your `DESCRIPTION` file by calling `use_package("name")`, so in this case:

```{r, eval=FALSE}
use_package("progress")
```

If you're using external functions, start using the package::function syntax as early as possible. Even if you're writing a function that you don't plan on using immediately using the package, it'll make it much easier to incorporate down the line. It's a lot more work to go package and add all the package names to the function after the fact. 

It may sound like a lot of first, but once you get used to it, you'll find that it can be helpful to be more intentional about naming your functions. This also avoid helps avoid naming conflicts. 

## Session Info

```{r}
session_info()
```

